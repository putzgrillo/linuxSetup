options(dplyr.summarise.inform = FALSE)
library(glmnet)
library(tidyverse)    


setwd('/mnt/2892419C92416F7E/EuroJobs/Booking/')

# import data
p1_df <- readxl::read_xlsx('HMS DSI Problem Set 2.xlsx',
                           sheet = "Problem1",
                           range = "A1:H10001", col_names = TRUE)

# cost data
df_cost <- data.frame(campaign = letters[1:4],
                      cost = c(7, 5, 4, 2) / 5)

# adjusting the data
df_path <- p1_df %>%
  # remove conversion and value to add later (only for last non NA click)
  select(-conversion, -value) %>%
  # turn into long format, keep until endpoints and change 'click_x' to numeric x
  pivot_longer(-user, names_to = "iteration", values_to = "campaign") %>%
  filter(!is.na(campaign)) %>%
  mutate(iteration = as.numeric(gsub('click_', '', iteration))) %>%
  # amount of campaigns (soon it will be replaced by their cumsum)
  mutate(
    campaign_a = as.numeric(campaign == 'a'),
    campaign_b = as.numeric(campaign == 'b'),
    campaign_c = as.numeric(campaign == 'c'),
    campaign_d = as.numeric(campaign == 'd')
  ) %>%
  # include generated costs
  left_join(., df_cost, by = "campaign") %>%
  # to each user
  group_by(user) %>%
  # do generate: cumulative cost, index of max_iteration, what was the previous campaign
    # max_iter index will be removed (just a temp key to attribute conversion & value)
  mutate(
    across(starts_with("campaign_"), .fns = cumsum),
    previous_campaign = ifelse(iteration > 1, lag(campaign, 1), "begin"),
    max_iter = max(iteration[!is.na(campaign)]),
    cost_cum = cumsum(cost)
  ) %>%
  # collect the conversion and value generated by each client
  left_join(., {p1_df %>% select(user, conversion, value)}, by = "user") %>%
  # attribute the conversion and value generated only to last non NA iteration of each customer
  mutate(
    conversion = ifelse(iteration == max_iter, conversion, 0),
    value = ifelse(iteration == max_iter, value, 0)
  ) 

# df_path %>% filter(user == 5)




# data with the last observation of each customer (endpoint)
df_last_state <- df_path %>%
  arrange(-iteration) %>%
  group_by(user) %>%
  slice(1) %>% ungroup() 


# generate all combinations of marketing (if customer received contact of a given combination)
df_mix_comb <- 
  expand.grid(campaign_a = 0:1,
              campaign_b = 0:1,
              campaign_c = 0:1,
              campaign_d = 0:1) %>% 
  as.data.frame()
df_mix_comb <- df_mix_comb[apply(df_mix_comb, 1, sum) > 0, ]

# start bootstrap to generate metrics of interest
n_bootstrap <- 250
df_combinations <- vector("list", nrow(df_mix_comb))

for (w in seq_along(df_combinations)) {
  # set current iteration
  temp_bootstrap <- vector("list", n_bootstrap)
  
  for (y in seq_along(temp_bootstrap)) {
    # summarise important variables given a sample
    temp_inboot <- df_last_state %>%
      filter(
        sign(campaign_a) == df_mix_comb$campaign_a[w]
        & sign(campaign_b) == df_mix_comb$campaign_b[w]
        & sign(campaign_c) == df_mix_comb$campaign_c[w]
        & sign(campaign_d) == df_mix_comb$campaign_d[w]
      ) %>% ungroup() %>%
      sample_frac(0.4) %>%
      summarise(
        conv_rate = mean(conversion),                     # what is the conversion rate
        mean_value = mean(value),                         # what is the mean value (not omitting zero)
        mean_cost = mean(cost_cum),                       # average incurred cost (current)
        across(starts_with("campaign_"), .fns = sum)      # sum amount of clicks (temp to compute cost share)
      ) %>%
      mutate(
        mean_profit = mean_value - mean_cost,
        mean_return = mean_profit / mean_cost - 1
      )
    
    # add a table with cost share per campaign 
    temp_share <- temp_inboot %>%
      select(starts_with("campaign_")) %>%
      pivot_longer(everything(), names_to = "campaign", values_to = "times") %>%
      mutate(campaign = gsub("campaign_", "", campaign))%>%
      left_join(., df_cost, by = "campaign") %>%
      mutate(cost = times * cost) %>%
      mutate(share = cost / sum(cost)) %>%
      select(campaign, share) %>%
      pivot_wider(names_from = campaign, values_from = share, 
                  names_prefix = "share_campaign_")
    
    # adjust campaign_ to binary
    temp_inboot <- temp_inboot %>%
      mutate(across(starts_with("campaign_"), .fns = sign))
    
    # join tables
    temp_bootstrap[[y]] <- bind_cols(temp_inboot, 
                                     temp_share)
    rm(list = c("temp_inboot", "temp_share"))
  }
  
  df_combinations[[w]] <- bind_rows(temp_bootstrap)
  rm(temp_bootstrap)
}

# df for inference
df_inference <- bind_rows(df_combinations)


# modelling outcome: most successful in terms of unit sales contributed? ----
df_folds <- df_inference %>%
  rsample::vfold_cv(v = 10, repeats = 2)

model_recipe_nointeraction <- recipe(diff_ltv ~ ., data = p3_train_data) %>%
  update_role(userID, new_role = "ID") %>%
  step_log(commission) %>%
  step_normalize(length_of_stay, commission) %>%
  step_date(bookDate, features = c('dow', 'quarter')) %>%
  step_num2factor(ends_with("quarter"), levels = c('q1', 'q2', 'q3', 'q4')) %>%
  step_dummy(all_nominal(), ends_with("quarter")) %>%
  step_rm(bookDate)

model_recipe_interaction <- model_recipe_nointeraction %>%
  step_interact(~all_predictors():all_predictors())

dependent_variable <- as.matrix(df_inference$conv_rate)
cv_lasso <- cv.glmnet(y = matrix(df_path$conversion, ncol = 1),
                      x = as.matrix(df_path %>% select(starts_with("campaign_"))),
                      family = "binomial",
                      alpha = 1,
                      nfolds = 15,
                      intercept = TRUE)

coef(cv_lasso, s = "lambda.1se")
